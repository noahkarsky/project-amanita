<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>D3 Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/d3-dsv.v3.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        svg {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        .node {
            stroke: rgb(39, 87, 177);
            fill: rgb(39, 87, 177);
            stroke-width: 2;
        }

        .link {
            stroke: rgb(0, 0, 0);
            stroke-width: 2;
        }

        .tooltip {
            position: absolute;
            z-index: 999;
            background-color: rgb(255, 255, 255);
            border: 1px solid black;
            padding: 5px;
            font-size: 12px;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <svg></svg>
    <div class="tooltip" style="display: none;"></div>
    <script>
        // Load the nodes and edges CSV files using d3.csv()
        Promise.all([
            d3.csv('data/nodes.csv'),
            d3.csv('data/edges.csv')
        ]).then(function (data) {
            var nodes = data[0];
            var edges = data[1];
            var color = d3.scaleOrdinal(d3.schemeCategory10);

            nodes.forEach(function (node) {
                if (node.properties) {
                    try {
                        node.properties = JSON.parse(node.properties);
                        node.name = node.properties.properties.name; // Change this line
                    } catch (e) {
                        console.error(`Error parsing properties for node ${node.id}: ${e}`);
                    }
                } else {
                    console.error(`Node ${node.id} has undefined properties`);
                }
                console.log(node.name); // Add this line to check the name value
            });


            // Create a D3 force simulation
            var simulation = d3.forceSimulation(nodes)
                .force("link", d3.forceLink(edges).id(d => d.id))
                .force("charge", d3.forceManyBody().strength(-50))
                .force("center", d3.forceCenter(window.innerWidth / 2, window.innerHeight / 2));

            var svg = d3.select('svg');
            var g = svg.append("g");

            //add a zooming functionality
            var zoom = d3.zoom()
                .scaleExtent([0.1, 10])
                .on("zoom", zoomed);

            svg.call(zoom);

            // Create SVG lines for each edge
            var link = g.selectAll(".link") // Changed from svg.selectAll to g.selectAll
                .data(edges)
                .join("line")
                .attr("class", "link");

            // Create SVG circles for each node
            var node = g.selectAll(".node") // Changed from svg.selectAll to g.selectAll
                .data(nodes)
                .join("circle")
                .attr("class", "node")
                .attr("r", 15) // Increased the radius from 10 to 15
                .on("mouseover", showTooltip)
                .on("mousemove", moveTooltip)
                .on("mouseout", hideTooltip)
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended));




            // Create text labels for each node
            var label = g.selectAll(".label") // Changed from svg.selectAll to g.selectAll
                .data(nodes)
                .join("text")
                .text(function (d) { return d.name; })
                .attr("class", "label");

            // Update the visualization on each tick of the simulation
            simulation.on("tick", function () {
                link
                    .attr("x1", function (d) { return d.source.x; })
                    .attr("y1", function (d) { return d.source.y; })
                    .attr("x2", function (d) { return d.target.x; })
                    .attr("y2", function (d) { return d.target.y; })

                node
                    .attr("cx", function (d) { return d.x; })
                    .attr("cy", function (d) { return d.y; })
                label
                    .attr('x', function (d) { return d.x + 20; }) // Increased the x offset from 15 to 20
                    .attr('y', function (d) { return d.y + 5; });
            });

            // Drag functions
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            function dragended(event, d) {
    if (!event.active) simulation.alphaTarget(0);
    d.fx = d.x; // Change this line
    d.fy = d.y; // Change this line
}


            // Show tooltip function
            function showTooltip(event, d) {
                d3.select('.tooltip')
                    .style('display', 'block')
                    .html(d.name + '<br>' + d.properties.notes) // Changed from d.notes to d.properties.notes
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY + 10) + 'px');
            }

            // Move tooltip function
            function moveTooltip(event) {
                d3.select('.tooltip')
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY + 10) + 'px');
            }

            // Hide tooltip function
            function hideTooltip() {
                d3.select('.tooltip')
                    .style('display', 'none');
            }

            // zoom function
            function zoomed(event) {
                g.attr("transform", event.transform);
            }
        })
    </script>
</body>

</html>