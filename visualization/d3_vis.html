<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>D3 Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/d3-dsv.v3.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        svg {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        .node {
            stroke: rgb(0, 0, 0);
        }

        .label {
            font-size: 10px;
            text-anchor: middle;
            white-space: pre-wrap; 
            /* // wrap text */
            /* // https://stackoverflow.com/questions/24784302/wrapping-text-in-d3 */
            
        }

        .link {
            stroke: rgb(0, 0, 0);
            stroke-width: 1.3;
        }

        .edgeLabel {
            font-size: 12px;
            fill: #333;
        }

        .tooltip {
            position: absolute;
            z-index: 999;
            background-color: rgb(255, 255, 255);
            border: 1px solid black;
            padding: 5px;
            font-size: 12px;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <svg></svg>
    <div class="tooltip" style="display: none;"></div>
    <script>
        const labelThreshold = 2;
        // Load the nodes and edges CSV files using d3.csv()
        Promise.all([
            d3.csv('data/nodes.csv'),
            d3.csv('data/edges.csv')
        ]).then(function (data) {
            var nodes = data[0];
            var edges = data[1];// Define a custom color map
            var colorMap = {
                'program': '#4e79a7',
                'person': '#f28e2c',
                'position': '#e15759',
                'publication': '#76b7b2',
                'event': '#59a14f',
                'place': '#edc948',
                'concept': '#b07aa1',
                'organization': '#ff9da7',
                'group': '#9c755f',
                'date': '#bab0ac',
                'civilian_contractor': '#9467bd',
                'object': '#d37295',
                'technology': '#17becf'
            };

            nodes.forEach(function (node) {
                if (node.properties) {
                    try {
                        node.properties = JSON.parse(node.properties);
                        node.name = node.properties.properties.name; // Change this line
                    } catch (e) {
                        console.error(`Error parsing properties for node ${node.id}: ${e}`);
                    }
                } else {
                    console.error(`Node ${node.id} has undefined properties`);
                }
                console.log(node.name); // Add this line to check the name value
            });

            edges.forEach(function (edge) {
                if (edge.properties) {
                    edge.properties = JSON.parse(edge.properties);
                    edge.type = edge.properties.type; // Extract the type from the properties
                    if (edge.properties.properties) {
                        edge.notes = edge.properties.properties.notes; // Extract the notes if available
                    }
                }
            });


            var simulation = d3.forceSimulation(nodes)
                .force('collide', d3.forceCollide().radius(30))
                .force('charge', d3.forceManyBody().strength(-150))
                .alphaDecay(0.05)
                .force('link', d3.forceLink(edges).id(function (d) {
                    return d.id;
                }).distance(100))
                .force('center', d3.forceCenter(window.innerWidth / 2, window.innerHeight / 2))
                .on('tick', function () {
                    tick();
                })
                .on('end', function () {
                    if (options.zoomFit && !justLoaded) {
                        justLoaded = true;
                        zoomFit(2);
                    }
                });


            var svg = d3.select('svg');
            var defs = svg.append("defs"); // Add this line
            var g = svg.append("g");

            // Create SVG groups for each edge
            var linkGroup = g.selectAll(".linkGroup")
                .data(edges)
                .join("g")
                .attr("class", "linkGroup");


            // Create paths for each edge
            linkGroup.append("path")
                .attr("class", "link")
                .attr("id", function (d, i) { return `edge-path-${i}`; }) // Add unique ID to each path
                .attr("marker-end", "url(#arrow)"); // Add arrow marker


            // Add this block after creating the defs element
            defs.append("marker")
                .attr("id", "arrow")
                .attr("viewBox", "0 -5 10 10")
                .attr("refX", 32) // Set the position of the arrow marker to touch the node
                .attr("refY", 0)
                .attr("markerWidth", 9) // Reduce the markerWidth to make the arrowhead smaller
                .attr("markerHeight", 9) // Reduce the markerHeight to make the arrowhead smaller
                .attr("orient", "auto")
                .append("path")
                .attr("d", "M0,-5L10,0L0,5")
                .attr("class", "arrowHead");


            // Add zooming functionality
            var zoom = d3.zoom()
                .scaleExtent([0.1, 10])
                .on("zoom", zoomed);

            svg.call(zoom);

            // Create SVG circles for each node
            var node = g.selectAll(".node")
                .data(nodes)
                .join("circle")
                .attr("class", "node")
                .attr("r", 25)
                .attr("fill", function (d) { return colorMap[d.properties.labels]; })
                .on("mouseover", showTooltip)
                .on("mousemove", moveTooltip)
                .on("mouseout", hideTooltip)
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended));

            var label = g.selectAll(".label")
                .data(nodes)
                .join("text")
                .text(function (d) {
                    var maxLength = 50;
                    var label = d.name.length > maxLength ? d.name.substring(0, maxLength) + "..." : d.name;
                    return label;
                })
                .attr("class", "label")
                .attr("x", function (d) {
                    return d.x; // adjust the value to fine-tune the vertical position of the text
                })
                .attr("y", function (d) {
                    return d.y; // adjust the value to fine-tune the vertical position of the text
                })
            // .attr("dy", "1em"); // Adjust the y position to center the text vertically





            var edgeLabel = linkGroup.append("text")
                .attr("class", "edgeLabel")
                .append("textPath")
                .attr("startOffset", "50%")
                .attr("text-anchor", "middle")
                .attr("xlink:href", function (d, i) { return `#edge-path-${i}`; })
                .text(function (d) { return d.type; });


            // Update the visualization on each tick of the simulation
            simulation.on("tick", function () {
                linkGroup.select(".link").attr("d", function (d) {
                    return "M" + d.source.x + "," + d.source.y + " L" + d.target.x + "," + d.target.y;
                });


                node
                    .attr("cx", function (d) { return d.x; })
                    .attr("cy", function (d) { return d.y; })

                label
                    .attr('x', function (d) { return d.x; }) // Adjust the position of the text
                    .attr('y', function (d) { return d.y; });  // Adjust the position of the text

                edgeLabel
                    .attr("x", function (d) { return (d.source.x + d.target.x) / 2; })
                    .attr("y", function (d) { return (d.source.y + d.target.y) / 2; })
                    .text(function (d) { return d.type; });
            });

            
            // Drag functions
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = d.x;
                d.fy = d.y;
            }

            // Show tooltip function
            function showTooltip(event, d) {
                d3.select('.tooltip')
                    .style('display', 'block')
                    //fix this in the future
                    .html(d.name + '<br>' + 'notes:' + d.properties.properties.notes + '<br>' + 'start_date:' + d.properties.properties.start_date + '<br>' + 'end_date:' + d.properties.properties.end_date)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY + 10) + 'px');
            }

            // Move tooltip function
            function moveTooltip(event) {
                d3.select('.tooltip')
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY + 10) + 'px');
            }

            // Hide tooltip function
            function hideTooltip() {
                d3.select('.tooltip')
                    .style('display', 'none');
            }

            // Zoom function
            function zoomed(event) {
                g.attr("transform", event.transform);

                // Show or hide edge labels based on the zoom scale
                if (event.transform.k >= labelThreshold) {
                    linkGroup.select(".edgeLabel").style("display", "block"); // Show edge labels
                } else {
                    linkGroup.select(".edgeLabel").style("display", "none"); // Hide edge labels
                }
            }


        })
    </script>
</body>

</html>