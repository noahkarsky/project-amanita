<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>D3 Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/d3-dsv.v3.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        svg {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        .node {
            stroke: rgb(0, 0, 0);
        }

        .label {
            font-size: 10px;
            text-anchor: middle;
            white-space: pre-wrap;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-weight: 500;
            fill: #333;
        }

        .link {
            stroke: rgb(0, 0, 0);
            stroke-width: 1.3;
        }

        .edgeLabel {
            font-size: 10px;
            fill: #333;
            display: none;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-weight: 500;
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.5);
        }

        .tooltip {
            position: absolute;
            z-index: 999;
            background-color: rgba(255, 255, 255, 0.9);
            border: 1px solid black;
            padding: 10px;
            font-size: 14px;
            pointer-events: none;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            max-width: 300px;
            line-height: 1.4;
        }

        .tooltip h4 {
            margin: 0 0 5px 0;
            font-weight: bold;
        }

        .tooltip p {
            margin: 0;
        }
    </style>
</head>

<body>
    <svg></svg>
    <div class="tooltip" style="display: none;"></div>
    <script>
        const labelThreshold = 2; // Set the zoom threshold for showing/hiding edge labels
        // Load the nodes and edges CSV files using d3.csv()
        Promise.all([
            d3.csv('data/nodes.csv'),
            d3.csv('data/edges.csv')
        ]).then(function (data) {
            var nodes = data[0];
            var edges = data[1];// Define a custom color map
            var colorMap = {
                'program': '#4e79a7',
                'person': '#f28e2c',
                'position': '#e15759',
                'publication': '#76b7b2',
                'event': '#59a14f',
                'place': '#edc948',
                'concept': '#b07aa1',
                'organization': '#ff9da7',
                'group': '#9c755f',
                'date': '#bab0ac',
                'civilian_contractor': '#9467bd',
                'object': '#d37295',
                'technology': '#17becf'
            };

            nodes.forEach(function (node) {
                if (node.properties) {
                    try {
                        node.properties = JSON.parse(node.properties);
                        node.name = node.properties.properties.name; // Change this line
                    } catch (e) {
                        console.error(`Error parsing properties for node ${node.id}: ${e}`);
                    }
                } else {
                    console.error(`Node ${node.id} has undefined properties`);
                }
                console.log(node.name); // Add this line to check the name value
            });

            edges.forEach(function (edge) {
                if (edge.properties) {
                    edge.properties = JSON.parse(edge.properties);
                    edge.type = edge.properties.type; // Extract the type from the properties
                    if (edge.properties.properties) {
                        edge.notes = edge.properties.properties.notes; // Extract the notes if available
                    }
                }
            });


            var simulation = d3.forceSimulation(nodes)
                .force('collide', d3.forceCollide().radius(30))
                .force('charge', d3.forceManyBody().strength(-150))
                .alphaDecay(0.05)
                .force('link', d3.forceLink(edges).id(function (d) {
                    return d.id;
                }).distance(100))
                .force('center', d3.forceCenter(window.innerWidth / 2, window.innerHeight / 2))
                .on('tick', function () {
                    tick();
                })
                .on('end', function () {
                    if (options.zoomFit && !justLoaded) {
                        justLoaded = true;
                        zoomFit(2);
                    }
                });


            var svg = d3.select('svg');
            var defs = svg.append("defs"); // Add this line
            var g = svg.append("g");

            // Create SVG groups for each edge
            var linkGroup = g.selectAll(".linkGroup")
                .data(edges)
                .join("g")
                .attr("class", "linkGroup");


            // Create paths for each edge
            linkGroup.append("path")
                .attr("class", "link")
                .attr("id", function (d, i) { return `edge-path-${i}`; }) // Add unique ID to each path
                .attr("marker-end", "url(#arrow)"); // Add arrow marker


            // Add this block after creating the defs element
            defs.append("marker")
                .attr("id", "arrow")
                .attr("viewBox", "0 -5 10 10")
                .attr("refX", 32) // Set the position of the arrow marker to touch the node
                .attr("refY", 0)
                .attr("markerWidth", 9) // Reduce the markerWidth to make the arrowhead smaller
                .attr("markerHeight", 9) // Reduce the markerHeight to make the arrowhead smaller
                .attr("orient", "auto")
                .append("path")
                .attr("d", "M0,-5L10,0L0,5")
                .attr("class", "arrowHead");


            // Add zooming functionality
            var zoom = d3.zoom() // Create the zoom object
                .scaleExtent([0.1, 13]) //this line controls "how much" you can zoom in, lets make it a little more zoomed out

                .on("zoom", zoomed); // This line tells D3 what to do when the zoom event is fired

            svg.call(zoom);

            // Create SVG circles for each node
            var node = g.selectAll(".node")
                .data(nodes)
                .join("circle")
                .attr("class", "node")
                .attr("r", 27)
                .attr("fill", function (d) { return colorMap[d.properties.labels]; })
                .on("mouseover", showTooltip)
                .on("mousemove", moveTooltip)
                .on("mouseout", hideTooltip)
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended));

            var label = g.selectAll(".label")
                .data(nodes)
                .join("text")
                .attr("class", "label")
                .attr("x", function (d) {
                    return d.x;
                })
                .attr("y", function (d) {
                    return d.y;
                })
                .each(function (d) {
                    var maxLengthPerLine = 10;
                    var maxLengthTotal = 30;
                    var words = d.name.split(' ');
                    var line = '';
                    var lineNumber = 0;
                    var charCount = 0;
                    var lineHeight = 1.1; // ems
                    var tspan = d3.select(this).append("tspan") // Add first tspan element to label text this 
                        .attr("x", function () { // Set the x position
                            return d.x;
                        })
                        .attr("y", function () {
                            return d.y;
                        })
                        .attr("dy", `${lineHeight - 2}em`);
                    words.forEach(function (word, i) {
                        if (charCount + word.length <= maxLengthTotal) {
                            var testLine = line + word + " ";
                            if (testLine.length > maxLengthPerLine) {
                                tspan.text(line);
                                line = word + " ";
                                lineNumber += 1;
                                tspan = d3.select(tspan.node().parentNode).append("tspan")
                                    .attr("x", function () { // Set the x position 
                                        return d.x;
                                    })
                                    .attr("y", function () {
                                        return d.y;
                                    })
                                    .attr("dy", `${(lineNumber + 1) * lineHeight - 2}em`)
                                    .text(line);
                            } else {
                                line = testLine;
                            }
                            charCount += word.length + 1;
                        } else {
                            // If adding the current word will exceed maxLengthTotal
                            if (i === words.length - 1 || charCount + 3 > maxLengthTotal) {
                                tspan.text(line.slice(0, -1) + '...');
                            }
                        }
                        if (i === words.length - 1 && charCount <= maxLengthTotal) {
                            tspan.text(line);
                        }
                    });
                });
            // Add event listeners for the label elements
            label.on("mouseover", showTooltip)
                .on("mousemove", moveTooltip)
                .on("mouseout", hideTooltip)
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended));






            var edgeLabel = linkGroup.append("text")
                .attr("class", "edgeLabel")
                .append("textPath")
                .attr("startOffset", "50%")
                .attr("text-anchor", "middle")
                .attr("xlink:href", function (d, i) { return `#edge-path-${i}`; })
                .attr("dy", function (d) {
                    var angle = Math.atan2(d.target.y - d.source.y, d.target.x - d.source.x) * 180 / Math.PI;
                    return (angle > 90 || angle < -90) ? "-0.4em" : "1.2em";
                })
                .text(function (d) { return d.type; });



            // Update the visualization on each tick of the simulation
            simulation.on("tick", function () {
                linkGroup.select(".link").attr("d", function (d) {
                    return "M" + d.source.x + "," + d.source.y + " L" + d.target.x + "," + d.target.y;
                });


                node
                    .attr("cx", function (d) { return d.x; })
                    .attr("cy", function (d) { return d.y; })

                label
                    .attr('x', function (d) { return d.x; }) // Adjust the position of the text
                    .attr('y', function (d) { return d.y; })  // Adjust the position of the text
                    .selectAll("tspan") // Select all tspan elements inside the labels
                    .attr("x", function (d) { return d.x; }) // Update the x position of the tspan elements
                    .attr("y", function (d) { return d.y; }); // Update the y position of the tspan elements

                edgeLabel
                    .attr("x", function (d) { return (d.source.x + d.target.x) / 2; })
                    .attr("y", function (d) { return (d.source.y + d.target.y) / 2; })
                    .text(function (d) { return d.type; });
            });


            // Drag functions
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = d.x;
                d.fy = d.y;
            }

            // Show tooltip function
            // Show tooltip function
            function showTooltip(event, d) {
                d3.select('.tooltip')
                    .style('display', 'block')
                    .html('<h4>' + d.name + '</h4>'
                        + '<p><strong>Notes:</strong> ' + (d.properties.properties.notes || 'N/A') + '</p>'
                        + '<p><strong>Start Date:</strong> ' + (d.properties.properties.start_date || 'N/A') + '</p>'
                        + '<p><strong>End Date:</strong> ' + (d.properties.properties.end_date || 'N/A') + '</p>')
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY + 10) + 'px');
            }


            // Move tooltip function
            function moveTooltip(event) {
                d3.select('.tooltip')
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY + 10) + 'px');
            }

            // Hide tooltip function
            function hideTooltip() {
                d3.select('.tooltip')
                    .style('display', 'none');
            }

            // Zoom function
            function zoomed(event) {
                g.attr("transform", event.transform);

                // Show or hide edge labels based on the zoom scale
                if (event.transform.k >= labelThreshold) {
                    linkGroup.select(".edgeLabel").style("display", "block"); // Show edge labels
                } else {
                    linkGroup.select(".edgeLabel").style("display", "none"); // Hide edge labels
                }
            }


        })
    </script>
</body>

</html>